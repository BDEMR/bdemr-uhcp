<link rel="import" href="../../bower-assets/iron-icons/iron-icons.html">
<link rel="import" href="../../bower-assets/paper-button/paper-button.html">
<link rel="import" href="../../bower-assets/paper-card/paper-card.html">
<link rel="import" href="../../bower-assets/paper-input/paper-input.html">
<link rel="import" href="../../bower-assets/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../bower-assets/paper-menu/paper-menu.html">
<link rel="import" href="../../bower-assets/paper-item/paper-item.html">
<link rel="import" href="../../bower-assets/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../bower-assets/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower-assets/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../../behaviors/common-computes.html">
<link rel="import" href="../../behaviors/db-using.html">
<link rel="import" href="../../behaviors/translating.html">
<link rel="import" href="../../behaviors/api-calling.html">

<link rel="import" href="../../styles/common-style.html">
<link rel="import" href="visit-common-styles.html">

<!-- custom-elements -->
<link rel="import" href="../html-block/html-block.html">

<dom-module id="element-history-physical">
  <template>
    <style is="custom-style" include="common-style visit-common-styles">
    </style>

    <div class="card-item-2">

      <!-- preview-title - start -->
      <div class="preview-title layout wrap">
        <!-- <iron-icon class="m-right-8" src="../../images/icons/ico_history_and_physical.png"></iron-icon> -->

        <div class="type title-2 flex">History &amp; Physical</div>


        <div class="layout horizontal wrap">


          <template is="dom-if" if="[[_isEmptyString(visit.historyAndPhysicalRecordSerial)]]">
            <paper-button class="btn-add" on-tap="historyAndPhysicalRecordCreate">
              <iron-icon icon="add"></iron-icon>
            </paper-button>


            <template is="dom-if" if="[[recordInClipboard]]">
              <paper-button class="btn-add btn btn-default" on-tap="pasteRecordPressed">
                <iron-icon icon="icons:content-paste" class="m-right-8"></iron-icon>Paste Record: [[recordInClipboard.serial]]
              </paper-button>
            </template>
          </template>

          <template is="dom-if" if="[[!_isEmptyString(visit.historyAndPhysicalRecordSerial)]]">
            <paper-checkbox checked="[[historyAndPhysicalRecord.availableToPatient]]" on-change="historyAndPhysicalAvailableToPatientCheckBoxChanged">Available to Patient</paper-checkbox>

            <!-- <paper-icon-button icon="print" on-tap="historyAndPhysicalRecordPrint"></paper-icon-button> -->

            <paper-icon-button icon="create" on-tap="historyAndPhysicalRecordEdit"></paper-icon-button>
            <paper-icon-button icon="icons:content-copy" on-tap="historyAndPhysicalRecordCopy"></paper-icon-button>
            <paper-icon-button icon="icons:delete" on-tap="historyAndPhysicalRecordRemove"></paper-icon-button>

            <!-- <div>[[$mkDate(record.content.preopAssessment.lastChangedDatetimeStamp)]]</div> -->
          </template>
        </div>
      </div>
      <!-- preview-title - end -->


      <template is="dom-if" if="[[shouldRender]]">
        <div class="p-horizontal-16" style="background: #fff;">
          <html-block html="[[recordPartHtmlContent]]"></html-block>
        </div>
      </template>
    </div>

  </template>
  <script src="mixin-utils.js"></script>
  <script>
    Polymer({
      is: 'element-history-physical',
      behaviors: [
        app.behaviors.commonComputes,
        app.behaviors.dbUsing,
        app.behaviors.translating,
        app.behaviors.apiCalling,
        app.behaviors.local.visitUtilsMixin
      ],
      properties: {
        patient: Object,
        user: Object,
        visit: {
          type: Object,
          observer: 'visitValueChanged'
        },
        organization: {
          type: Object
        },
        historyAndPhysicalRecord: {
          type: Object
        },
        matchingRecordList: {
          type: Object
        }
      },

      attached: function () {
        this.historyAndPhysicalRecord = {}
      },

      detached: function () {

      },

      patientValueChanged: function (patient) {
        this.historyAndPhysicalRecord = {}
      },

      _getRecord(recordIdentifier, desiredRecordType) {
        let list = app.db.find(desiredRecordType, (item) => item.serial == recordIdentifier);
        return (list.length == 1) ? list[0] : null
      },

      visitValueChanged: function (visit) {

        if (!visit) return
        if (visit.serial) {
          if (visit.historyAndPhysicalRecordSerial) {
            this.historyAndPhysical_navigatedIn();

            this.set('recordPartName', 'history-and-physical-record');

            this.recordDatabaseCollectionName = 'history-and-physical-record';

            this.record = this._getRecord(this.visit.historyAndPhysicalRecordSerial, this.recordDatabaseCollectionName);

            this.recordPartData = this.record;

            this.recordPartTitle = 'History and Physical Record';

            this.domHost.domHost.getStaticData('dynamicElementDefinitionPreoperativeAssessment', def => {

              this.recordPartDef = def;

              this.recordPartHtmlContent = this.generateHtmlContent(this.recordPartDef, this.recordPartData);

              // console.log @recordPartHtmlContent

              if (!this.delayRendering) {

                return this.shouldRender = true;
              }
            });
          }
        }
      },

      historyAndPhysicalAvailableToPatientCheckBoxChanged(e) {
        if (this.historyAndPhysicalRecord) {
          if (e.target.checked) {
            this.historyAndPhysicalRecord.availableToPatient = true;
            return this._saveHistoryAndPhysicalRecord();
          } else {
            this.historyAndPhysicalRecord.availableToPatient = false;
            return this._saveHistoryAndPhysicalRecord();
          }
        }
      },

      historyAndPhysical_navigatedIn() {
        this._loadHistoryAndPhysicalRecord();
        this._loadRecordInClipboard();
      },

      historyAndPhysicalRecordCreate(e) {
        const params = this.domHost.domHost.getPageParams();
        if (params['visit'] === 'new') {
          this.domHost._saveVisit();
        }
        // console.log @visit.serial
        this.historyAndPhysicalRecord = {
          lastModifiedDatetimeStamp: lib.datetime.now(),
          createdDatetimeStamp: lib.datetime.now(),
          lastSyncedDatetimeStamp: 0,
          createdByUserSerial: this.user.serial,
          organizationId: this.organization.idOnServer,
          serial: this.generateSerialForHistoryAndPhysical(),
          patientSerial: this.patient.serial,
          visitSerial: this.visit.serial,
          availableToPatient: true
        };
        this.visit.historyAndPhysicalRecordSerial = this.historyAndPhysicalRecord.serial;
        this.visit.lastModifiedDatetimeStamp = lib.datetime.now();

        // updated visit object for History and Physical
        app.db.upsert('doctor-visit', this.visit, ({ serial }) => this.visit.serial === serial);


        this._saveHistoryAndPhysicalRecord();
        this._loadHistoryAndPhysicalRecord();
        this.domHost.domHost.navigateToPage(`#/record-history-and-physical/record:${this.historyAndPhysicalRecord.serial}`);
        return window.location.reload();
      },


      _loadRecordInClipboard() {
        let recordInClipboard = sessionStorage.getItem('HISTORY-AND-PHYSICAL-IN-CLIPBOARD');
        if (recordInClipboard) {
          recordInClipboard = JSON.parse(recordInClipboard);
        }
        return this.recordInClipboard = recordInClipboard;
      },

      historyAndPhysicalRecordCopy(e) {
        const record = this.historyAndPhysicalRecord;
        // console.log record

        sessionStorage.setItem('HISTORY-AND-PHYSICAL-IN-CLIPBOARD', JSON.stringify(record));
        this.domHost.domHost.showModalDialog("This record has been copied to clipboard");
        return this._loadRecordInClipboard();
      },

      pasteRecordPressed(e) {
        const params = this.domHost.domHost.getPageParams();
        if (params['visit'] === 'new') {
          this.domHost._saveVisit();
        }

        this.recordInClipboard.patientSerial = this.patient.serial;
        this.recordInClipboard.visitSerial = this.visit.serial;
        this.recordInClipboard.lastChangedDatetimeStamp = lib.datetime.now();
        this.recordInClipboard.serial = this.generateSerialForRecord();

        this.visit.historyAndPhysicalRecordSerial = this.recordInClipboard.serial;
        this.historyAndPhysicalRecord = this.recordInClipboard;


        // updated visit object for History and Physical
        app.db.upsert('doctor-visit', this.visit, ({ serial }) => this.visit.serial === serial);

        this._saveHistoryAndPhysicalRecord();
        this._loadHistoryAndPhysicalRecord();

        this.recordInClipboard = null;
        sessionStorage.removeItem('HISTORY-AND-PHYSICAL-IN-CLIPBOARD');

        this.domHost.domHost.showModalDialog("Successfully Imported. Reloading Interface.");

        this.domHost.domHost.navigateToPage(`#/record-history-and-physical/record:${this.historyAndPhysicalRecord.serial}`);
        return window.location.reload();
      },

      _updateVisitForHistoryAndPhysicalRecord(historyAndPhysicalRecordIdentifier) { },

      historyAndPhysicalRecordPrint(e) {
        return this.domHost.domHost.navigateToPage(`#/print-history-and-physical-record/record:${this.historyAndPhysicalRecord.serial}`);
      },

      historyAndPhysicalRecordEdit(e) {
        return this.domHost.domHost.navigateToPage(`#/record-history-and-physical/record:${this.historyAndPhysicalRecord.serial}`);
      },

      historyAndPhysicalRecordRemove(e) {
        return this.domHost.domHost.showModalPrompt('Are you sure?', answer => {
          if (answer) {
            app.db.remove('history-and-physical-record', this.historyAndPhysicalRecord._id);
            return this._loadHistoryAndPhysicalRecord();
          }
        });
      },

      _loadHistoryAndPhysicalRecord() {
        const currentVisitSerial = this.visit.serial;
        const list = app.db.find('history-and-physical-record', ({ visitSerial }) => visitSerial === currentVisitSerial);
        if (list.length === 1) {
          this.set('historyAndPhysicalRecord', list[0]);
        } else {
          this.set('historyAndPhysicalRecord', null);
        }

        return console.log('_loadHistoryAndPhysicalRecord', this.historyAndPhysicalRecord);
      },

      _saveVisitPrescription() {
        app.db.upsert('visit-prescription', this.prescription, ({ serial }) => this.prescription.serial === serial);
        return this.domHost.domHost.showToast('Record Saved');
      },

      _saveVisitTestAdvised() {
        app.db.upsert('visit-advised-test', this.testAdvised, ({ serial }) => this.testAdvised.serial === serial);
        return this.domHost.domHost.showToast('Record Saved');
      },

      _saveHistoryAndPhysicalRecord() {
        app.db.upsert('history-and-physical-record', this.historyAndPhysicalRecord, ({ serial }) => this.historyAndPhysicalRecord.serial === serial);
        return this.domHost.domHost.showToast('Record Saved');
      },

      generateHtmlContent(def, data) {
        let html = this.handle_type(def, data.data);
        html = this.filterHtmlContent(html);
        return html;
      },

      filterHtmlContent(html) {
        html = html.replace(/@VALUE@/g, '');
        return html;
      },

      printOutStyleSheet() {
        return `\
        <style>
          
            .default-category {
              /* font-size: 20px; 
              font-weight: bold; */
              text-align: center; 
            }
            .default-collection {
              /* font-size: 16px; 
              font-weight: bold; */
            }
            .default-group {
              /* text-decoration: overline; */
            }
            .default-card {
              /* text-decoration: underline; */
            }
            span {
              font-size: 14px;
            }
            .unprocessed {
              color: red;
            }
        </style>\
        `;
      },

      handle_children(def, data) {
        if (!data || !def) return;
        let html = '';
        if ('childMap' in data && 'childList' in def && (def.childList !== null)) {
          for (let childIndex = 0; childIndex < def.childList.length; childIndex++) {
            const child = def.childList[childIndex];
            if (child.key in data.childMap) {
              let childHtml = this.handle_type(child, data.childMap[child.key]);
              if (childHtml && !([';', ':;', ': ;'].includes(childHtml))) {
                childHtml = this.sanitizeOutput(childHtml);
                html += childHtml;
              }
            }
          }
        } else {
          console.log('end-case');
        }
        return html;
      },

      handle_type(def, data) {
        // console.log def.key, @listPrintDirectives def
        if (!('print' in def)) { def.print = {}; }
        if (def.type === 'systemRoot') {
          this.flattenStyle(def);
          return this.type_systemRoot(def, data);
        } else if (def.type === 'category') {
          if (!('boldLabel' in def.print)) { def.print.boldLabel = true; }
          if (!('fontSize' in def.print)) { def.print.fontSize = 18; }
          this.flattenStyle(def);
          return this.type_category(def, data);
        } else if (def.type === 'collection') {
          if (!('boldLabel' in def.print)) { def.print.boldLabel = true; }
          if (!('fontSize' in def.print)) { def.print.fontSize = 16; }
          this.flattenStyle(def);
          return this.type_collection(def, data);
        } else if (def.type === 'group') {
          if (!('passThrough' in def.print)) { def.print.passThrough = true; }
          if (!('fontSize' in def.print)) { def.print.fontSize = 14; }
          this.flattenStyle(def);
          return this.type_group(def, data);
        } else if (def.type === 'card') {
          if (!('boldLabel' in def.print)) { def.print.boldLabel = true; }
          if (!('fontSize' in def.print)) { def.print.fontSize = 14; }
          this.flattenStyle(def);
          return this.type_card(def, data);
        } else if (def.type === 'checkbox') {
          this.flattenStyle(def);
          return this.type_checkbox(def, data);
        } else if (def.type === 'toggleableContainer') {
          this.flattenStyle(def);
          return this.type_toggleableContainer(def, data);
        } else if (def.type === 'label') {
          this.flattenStyle(def);
          return this.type_label(def, data);
        } else if (def.type === 'autocomplete') {
          if ('selectionType' in def && (def.selectionType === 'label')) {
            if (!('separatorString' in def.print)) { def.print.separatorString = ", "; }
          }
          this.flattenStyle(def);
          return this.type_autocomplete(def, data);
        } else if (def.type === 'container') {
          this.flattenStyle(def);
          return this.type_container(def, data);
        } else if (def.type === 'checkList') {
          if (!('separatorString' in def.print)) { def.print.separatorString = ", "; }
          this.flattenStyle(def);
          return this.type_checkList(def, data);
        } else if (def.type === 'radioList') {
          if (!('separatorString' in def.print)) { def.print.separatorString = ", "; }
          this.flattenStyle(def);
          return this.type_radioList(def, data);
        } else if (def.type === 'input') {
          this.flattenStyle(def);
          return this.type_input(def, data);
        } else if (def.type === 'singleSelectDropdown') {
          this.flattenStyle(def);
          return this.type_singleSelectDropdown(def, data);
        } else if (def.type === 'incrementalCounter') {
          this.flattenStyle(def);
          return this.type_incrementalCounter(def, data);
        } else {
          return `<span class="unprocessed">UNPROCESSED ${def.type} - ${def.key}</span>`;
        }
      },


      flattenStyle(def) {
        if ('passThrough' in def.print) {
          if (!('hideLabel' in def.print)) {
            def.print.hideLabel = true;
          }
          if (!('noColonAfterThis' in def.print)) {
            def.print.noColonAfterThis = true;
          }
          if (!('noSemicolonAfterThis' in def.print)) {
            def.print.noSemicolonAfterThis = false;
          }
        }
        // delete def.print['passThrough']
        if ('newLineBeforeThis' in def.print) {
          if (typeof def.print.newLineBeforeThis === 'boolean') {
            def.print.newLineBeforeThis = (def.print.newLineBeforeThis === true ? 1 : 0);
          } else {
            def.print.newLineBeforeThis = parseInt(def.print.newLineBeforeThis);
          }
        }
        if ('newLineAfterThis' in def.print) {
          if (typeof def.print.newLineAfterThis === 'boolean') {
            def.print.newLineAfterThis = (def.print.newLineAfterThis === true ? 1 : 0);
          } else {
            def.print.newLineAfterThis = parseInt(def.print.newLineAfterThis);
          }
        }
        if ('newLineAfterThisAndChildren' in def.print) {
          if (typeof def.print.newLineAfterThisAndChildren === 'boolean') {
            def.print.newLineAfterThisAndChildren = (def.print.newLineAfterThisAndChildren === true ? 1 : 0);
          } else {
            def.print.newLineAfterThisAndChildren = parseInt(def.print.newLineAfterThisAndChildren);
          }
        }
        if ('newLineAfterEachValue' in def.print) {
          if (typeof def.print.newLineAfterEachValue === 'boolean') {
            return def.print.newLineAfterEachValue = (def.print.newLineAfterEachValue === true ? 1 : 0);
          } else {
            return def.print.newLineAfterEachValue = parseInt(def.print.newLineAfterEachValue);
          }
        }
      },

      sanitizeOutput(content) {
        for (let i = 0; i <= 2; i++) {
          content = content.replace(/\;;/g, ';');
          content = content.replace(/\;;/g, ';');
          content = content.replace(/\; ;/g, ';');
          content = content.replace(/\: ;/g, ';');
          content = content.replace(/\: :/g, ':');
          content = content.replace(/\, ;/g, ';');
          content = content.replace(/\; ,/g, ';');
          content = content.replace(/\,;/g, ';');

          content = content.replace(/<\/span style=""><\/span>/g, '');
          content = content.replace(/<\/span>;<\/span>/g, '<\/span><\/span>');
          content = content.replace(/<\/span>; <\/span>/g, '<\/span><\/span>');
          content = content.replace(/<\/span> ,<\/span>/g, '<\/span><\/span>');
        }

        return content;
      },


      /*
        REGION - VARIOUS TYPES
      */

      _computeElementStyle(def) {
        let style = '';
        if (def.print.fontSize) {
          style += `font-size: ${def.print.fontSize}px;`;
        }
        if (def.print.hide) {
          style += "display: none;";
        }
        return style;
      },

      _computeTitleOrLabelStyle(def) {
        let style = '';
        if (def.print.boldLabel) {
          style += "font-weight: bold;";
        }
        return style;
      },

      type_systemRoot(def, data) {
        const content = (this.handle_children(def, data));
        return this.printOutStyleSheet() + content;
      },

      type_category(def, data) {
        const content = this.handle_children(def, data);
        if (content.length === 0) { return ''; }
        let style = this._computeTitleOrLabelStyle(def);
        const title = `<span style="${style}">${def.label}</span>`;
        style = this._computeElementStyle(def);
        const html = `<div class="default-category" style="${style}">${title}</div>${content}`;
        return html;
      },

      type_collection(def, data) {
        let content;
        if ((Object.keys(data.childMap)).length === 0) { return ''; }
        if (def.defaultGroup && !data.isDefaultGroupDismissed) {
          content = this.handle_type(def.defaultGroup, data.childMap[def.defaultGroup.key]);
        } else {
          content = this.handle_children(def, data);
        }
        let style = this._computeTitleOrLabelStyle(def);
        const title = `<br><span style="${style}">${def.label}</span><br>`;
        style = this._computeElementStyle(def);
        const html = `<span class="default-collection" style="${style}">${title}</span>: ${content}<br>`;
        return html;
      },

      type_group(def, data) {
        let html;
        const content = this.handle_children(def, data);
        let style = this._computeTitleOrLabelStyle(def);
        const title = `<span style="${style}">${def.label}</span>`;
        if (def.print.passThrough) {
          html = `${content};`;
        } else {
          style = this._computeElementStyle(def);
          html = `<span class="default-group" style="${style}">${title}</span>: ${content}; `;
        }
        return html;
      },

      _makePrintableContent(label, content, value, def, data) {
        let i, style;
        if ((content.length === 0) && (value.length === 0) && (def.type !== 'label')) { return ''; }
        const { print } = def;

        // console.log label, print

        let labelHtml = '';
        let contentHtml = '';
        let valueHtml = '';

        if (print.hide) { return ''; }

        if (label.length > 0) {
          if (!print.hideLabel) {
            style = '';
            if (print.boldLabel) {
              style += 'font-weight: bold;';
            }
            if (print.fontSize) {
              style += `font-size:${print.fontSize}px;`;
            }
            labelHtml = `<span style="${style}">${label}</span>`;
          }
        }

        if (value.length > 0) {
          if (!print.hideValue) {
            style = '';
            if (print.boldValue) {
              style += 'font-weight: bold;';
            }
            if (print.fontSize) {
              style += `font-size:${print.fontSize}px;`;
            }
            valueHtml = `<span style="${style}">${value}</span>`;
          }
        }

        if (content.length > 0) {
          if (!print.hideChildren) {
            style = '';
            if (print.boldChildren) {
              style += 'font-weight: bold;';
            }
            contentHtml = `<span style="${style}">${content}</span>`;
          }
        }

        if ((labelHtml + contentHtml + valueHtml).length === 0) {
          return '';
        }

        if ('newLineBeforeThis' in print) {
          let asc, end;
          for (i = 0, end = print.newLineBeforeThis, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
            labelHtml = `<br>${labelHtml}`;
          }
        }

        if ('newLineAfterThis' in print) {
          let asc1, end1;
          for (i = 0, end1 = print.newLineAfterThis, asc1 = 0 <= end1; asc1 ? i < end1 : i > end1; asc1 ? i++ : i--) {
            labelHtml = labelHtml + '<br>';
          }
        }

        const colon = (('noColonAfterThis' in print && print.noColonAfterThis) || (labelHtml.length === 0) ? '' : ': ');
        const semicolon = ('noSemicolonAfterThis' in print && print.noSemicolonAfterThis ? '' : '; ');
        let html = labelHtml + colon + contentHtml + valueHtml + semicolon;

        if ('newLineAfterThisAndChildren' in print) {
          let asc2, end2;
          for (i = 0, end2 = print.newLineAfterThisAndChildren, asc2 = 0 <= end2; asc2 ? i < end2 : i > end2; asc2 ? i++ : i--) {
            html = html + '<br>';
          }
        }

        return html;
      },


      type_card(def, data) {
        const content = (this.handle_children(def, data));
        const { label } = def;
        const value = null;
        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_checkbox(def, data) {
        let value;
        const content = null;
        const label = null;

        if (data.isChecked) {
          value = def.label;
        } else {
          value = '';
        }

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_label(def, data) {
        const content = null;
        const label = data.label || def.label || def.defaultLabel;
        const value = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_toggleableContainer(def, data) {
        if (!data.isChecked) { return ''; }

        const content = this.handle_children(def, data);
        const { label } = def;
        const value = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_container(def, data) {
        const content = this.handle_children(def, data);
        const label = data.label || def.defaultLabel;
        const value = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_checkList(def, data) {
        const { print } = def;

        const stringList = [];
        for (let item of Array.from(data.checkedValueList)) {
          stringList.push(item);
        }

        let { separatorString } = print;
        if ('newLineAfterEachValue' in print) {
          for (let i = 0, end = print.newLineAfterEachValue, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
            separatorString += '<br>';
          }
        }

        const value = stringList.join(separatorString);

        const label = null;
        const content = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_radioList(def, data) {
        const value = data.selectedValue;
        const label = null;
        const content = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_singleSelectDropdown(def, data) {
        const value = def.possibleValueList[data.selectedIndex];
        const label = null;
        const content = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_input(def, data) {
        let content = data.value;

        if (def.unitDetails) {
          const unit = def.unitDetails.unitList[data.selectedUnitIndex];
        }
        // content += ' ' + unit.name

        const value = content;
        const { label } = def;
        content = null;

        return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
      },

      type_autocomplete(def, data) {
        let content, key, label, title, value;
        const { print } = def;

        if (def.selectionType === 'label') {

          const stringList = [];
          for (key in data.virtualChildMap) {
            value = data.virtualChildMap[key];
            title = key.split('_');
            title.pop();
            title.shift();
            title = title.join('_');
            stringList.push(title);
          }

          let { separatorString } = print;
          if ('newLineAfterEachValue' in print) {
            for (let i = 0, end = print.newLineAfterEachValue, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
              separatorString += '<br>';
            }
          }

          value = stringList.join(separatorString);

          ({ label } = def);
          content = null;

          return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);

        } else {
          content = '';
          for (key in data.virtualChildMap) {
            value = data.virtualChildMap[key];
            title = key.split('_');
            title.pop();
            title.shift();
            title = title.join('_');

            const virtualContainer = {
              type: 'container',
              defaultLabel: title,
              key,
              childList: def.childListForEachContainer
            };

            const childContent = (this.handle_type(virtualContainer, value)) + ', ';
            content += childContent;
          }

          value = null;
          ({ label } = def);

          return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
        }
      },

      type_incrementalCounter(def, data) {
        let content = '';
        for (let key in data.virtualChildMap) {
          let value = data.virtualChildMap[key];
          const title = key.replace('item', '');
          const serial = parseInt(title);

          const virtualContainer = {
            type: 'container',
            defaultLabel: ((() => { try { return def.unit.singular; } catch (ex) { return 'unit'; } })()) + ' #' + (serial + 1),
            key,
            childList: def.childListForEachContainer
          };

          content += (this.handle_type(virtualContainer, value)) + ';';

          value = null;
          const { label } = def;
          return this._makePrintableContent((label || ''), (content || ''), (value || ''), def, data);
        }
      },

      /*
        REGION - PRINT RELATED CHECKS
      */

      should_boldLabel(def) {
        return 'print' in def && 'boldLabel' in def.print && def.print.boldLabel;
      },

      should_passThrough(def) {
        return 'print' in def && 'passThrough' in def.print && def.print.passThrough;
      },

      should_newLineBeforeThis(def) {
        return 'print' in def && 'newLineBeforeThis' in def.print && def.print.newLineBeforeThis;
      },

      inject_passThrough_special_card(def, data) {
        if ((def.key === def.label) && ["Details", 'Default'].includes(def.key)) {
          if (!def.print) { def.print = {}; }
          return def.print.passThrough = true;
        }
      },

      inject_passThrough_special_group(def, data) {
        if ((def.key === def.label) && ["List", 'Default'].includes(def.key)) {
          if (!def.print) { def.print = {}; }
          return def.print.passThrough = true;
        }
      },

      __debug_print(def, handledDirectiveList) {
        const all = 'print' in def ? Object.keys(def.print) : [];
        const left = lib.array.minus(all, handledDirectiveList);
        if (left.length > 0) {
          return console.log('UNHANDLED print directives', def, left);
        }
      }

    });
  </script>
</dom-module>